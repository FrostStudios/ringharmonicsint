// ================================================================
// AVX2-OPTIMIERTER BEISPIELCODE – Vektoraddition, Harmonic Shift, Summation
// Kann in CODEX-Benchmarks direkt adaptiert werden
// ================================================================

#include <immintrin.h>
#include <iostream>
#include <vector>
#include <chrono>

constexpr int N = 4096; // Beispielgröße, vielfaches von 8 für AVX

// 1. AVX2 Vektoraddition
void add_avx(const int* a, const int* b, int* out, int n) {
    int i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256i va = _mm256_loadu_si256((const __m256i*)(a + i));
        __m256i vb = _mm256_loadu_si256((const __m256i*)(b + i));
        __m256i vsum = _mm256_add_epi32(va, vb);
        _mm256_storeu_si256((__m256i*)(out + i), vsum);
    }
    // Rest seriell
    for (; i < n; ++i) out[i] = a[i] + b[i];
}

// 2. AVX2 Harmonic Shift: y = (x * 9) & 0x1FF  (9-bit-Ring)
void harmonic_shift_avx(const int* in, int* out, int n) {
    __m256i factor = _mm256_set1_epi32(9);
    __m256i mask   = _mm256_set1_epi32(0x1FF);
    int i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256i vin = _mm256_loadu_si256((const __m256i*)(in + i));
        __m256i vmul = _mm256_mullo_epi32(vin, factor);
        __m256i vres = _mm256_and_si256(vmul, mask);
        _mm256_storeu_si256((__m256i*)(out + i), vres);
    }
    for (; i < n; ++i) out[i] = (in[i] * 9) & 0x1FF;
}

// 3. AVX2 Summation (Reduktion)
int sum_avx(const int* in, int n) {
    __m256i vsum = _mm256_setzero_si256();
    int i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256i v = _mm256_loadu_si256((const __m256i*)(in + i));
        vsum = _mm256_add_epi32(vsum, v);
    }
    // Horizontale Reduktion
    alignas(32) int buf[8];
    _mm256_store_si256((__m256i*)buf, vsum);
    int sum = buf[0] + buf[1] + buf[2] + buf[3] + buf[4] + buf[5] + buf[6] + buf[7];
    for (; i < n; ++i) sum += in[i];
    return sum;
}

// --- BENCHMARK MAIN ---
int main() {
    std::vector<int> a(N), b(N), out(N);
    for (int i = 0; i < N; ++i) {
        a[i] = i & 0x1FF;
        b[i] = (N - i) & 0x1FF;
    }

    // Vektoraddition
    auto t1 = std::chrono::high_resolution_clock::now();
    add_avx(a.data(), b.data(), out.data(), N);
    auto t2 = std::chrono::high_resolution_clock::now();
    std::cout << "AVX2 Addition: " << std::chrono::duration<double>(t2 - t1).count() << " s\n";

    // Harmonic Shift
    auto t3 = std::chrono::high_resolution_clock::now();
    harmonic_shift_avx(a.data(), out.data(), N);
    auto t4 = std::chrono::high_resolution_clock::now();
    std::cout << "AVX2 Harmonic Shift: " << std::chrono::duration<double>(t4 - t3).count() << " s\n";

    // Summation
    auto t5 = std::chrono::high_resolution_clock::now();
    int sum = sum_avx(out.data(), N);
    auto t6 = std::chrono::high_resolution_clock::now();
    std::cout << "AVX2 Summation: " << std::chrono::duration<double>(t6 - t5).count() << " s, Result: " << sum << "\n";

    return 0;
}
Hinweise:
Der Code nutzt AVX2. Für Kompilierung:
g++ -O2 -mavx2 -std=c++11 deinfile.cpp
Alle Kernfunktionen sind SIMD-beschleunigt und fallen auf seriell zurück, falls das Array nicht ganz aufgeht.
Kernfunktionen:
add_avx: Vektoraddition
harmonic_shift_avx: Multiplikation & Maskierung (dein „RingHarmonicsINT“-Prinzip)
sum_avx: Schnelle Reduktion (Summation)
Benchmark-Output: Zeigt die Laufzeiten für jede Funktion
N kann beliebig angepasst werden (idealerweise vielfaches von 8).
